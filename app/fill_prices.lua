---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by pronvis.
--- DateTime: 15/07/2018 15:54
---

local log = require 'log'
require('libraries.functions')

local M = {}
local app
local http_client
local json
local fiber
local clock

function M.init(config)
    clock = require'clock'
    app = require 'app'
    json = require 'json'
    fiber = require 'fiber'
    M.config = config
    http_client = require('http.client').new({5})
end

local function get_average_price(bids)
    local multiple_function = function(t) return t[1]*t[2] end
    local amount_on_price = map(multiple_function, bids)
    return reduce(operator.add, amount_on_price)
end

local function calc_avg_price(data)
    local res = {btc_count = 0, avg_price = 0 }
    local i = 0
    local data_length = table.getn(data)
    while(res.btc_count < 10 and i <= data_length) do
        i = i + 1
        local bid = data[i]
        res.btc_count = res.btc_count + bid[2]
        res.avg_price = res.avg_price + bid[1] * bid[2]
    end
    return res.avg_price / res.btc_count
end

function M.bts_to_usdt_avg_price(depth)
    local url = 'https://poloniex.com/public?command=returnOrderBook&currencyPair=USDT_BTC&depth='..depth
    local response = http_client:get(url, {timeout = 5})
    log.info('filler http response status:'..response.status)
    if response.body then
        local orders = json.decode(response.body)
        local sells = get_average_price(orders.asks)
        local buys = get_average_price(orders.bids)
        local avg_sell_price = calc_avg_price(orders.asks)
        local avg_buy_price = calc_avg_price(orders.bids)
        return sells, buys, avg_sell_price, avg_buy_price
    else
        log.error('fail to get response from poloneix')
    end
end

local function fill_prices_table()
    local sells, buys, avg_sell_price, avg_buy_price = M.bts_to_usdt_avg_price(100000)
    if sells and buys and avg_sell_price and avg_buy_price then
        local now = math.floor(clock.time()*1000)
        box.space.usdt_btc_orders:insert({now, sells, buys, avg_sell_price, avg_buy_price})
        log.debug('insert to prices; sells='..sells..'; buys='..buys..'; avg_sell_price='..avg_sell_price..'; avg_buy_price='..avg_buy_price)
    end
end

function M.fill_fiber(channel)
    local running = true
    while running do
        local task = channel:get()
        if task ~= nil then
            log.debug('filler successfuly get message from channel')
            fill_prices_table()
        else
            log.error('fill_fiber is stopped!')
            running = false
        end
    end
end

local fiber_channel
local filler_fiber
local awaker_fiber
function M.start()
    fiber_channel = fiber.channel()
    filler_fiber = fiber.create(M.fill_fiber, fiber_channel)
    filler_fiber:name('filler_fiber')

    local function awake_channel(channel)
        while true do
            local put_res = channel:put('', 5)
            if put_res then
                log.debug('awaker successfuly put message to channel')
            else
                log.debug('awaker fail to put message to channel')
            end
            fiber.sleep(1)
        end
    end
    awaker_fiber = fiber.create(awake_channel, fiber_channel)
    awaker_fiber:name('awaker_fiber')
end

function M.get_channel()
    return fiber_channel
end

function M.get_http_client()
    return http_client
end


function M.get_metric(name, value, ts)
    return name .. ' ' .. tostring(value) .. ' ' .. tostring(ts) .. '\n'
end

local socket = require('socket')
local sock = socket.tcp_connect('127.0.0.1', 2003)
function M.send_metric(name, value, ts)
    return sock:write(M.get_metric(name, value, ts))
end

function M.send_btc_data()
    for _, value in pairs(box.space.usdt_btc_orders:select{}) do
        local seconds = math.floor(value[1] / 1000)
        local sells = value[2]
        local buys = value[3]
        local avg_sell_price = value[4]
        local avg_buy_price = value[5]
        M.send_metric('btc.sells', sells, seconds)
        M.send_metric('btc.buys', buys, seconds)
        M.send_metric('btc.avg_sell_price', avg_sell_price, seconds)
        M.send_metric('btc.avg_buy_price', avg_buy_price, seconds)
    end
end

function M.destroy()
end

return M
